<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Visualizador 4D IFC en GitHub Pages</title>
  <style>
    body, html {
      margin: 0;
      overflow: hidden;
    }
    #container {
      width: 100vw;
      height: 80vh;
    }
    #controls {
      width: 100vw;
      text-align: center;
      padding: 10px;
      background-color: #f0f0f0;
    }
    #slider {
      width: 80%;
    }
    #dateDisplay {
      font-size: 1.2em;
      margin-bottom: 10px;
    }
    #legend {
      margin-top: 10px;
    }
    .legend-item {
      display: inline-block;
      margin-right: 20px;
    }
    .legend-color {
      display: inline-block;
      width: 20px;
      height: 20px;
      vertical-align: middle;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="controls">
    <div id="dateDisplay">Fecha: --/--/----</div>
    <input type="range" id="slider" min="0" max="100" value="0">
    <div>
      <button id="playButton">Reproducir</button>
      <button id="pauseButton">Pausar</button>
    </div>
    <div id="legend">
      <div class="legend-item">
        <span class="legend-color" style="background-color: #808080;"></span>No iniciado
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background-color: rgba(0, 255, 0, 0.3);"></span>En progreso
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background-color: #00ff00;"></span>Completado
      </div>
    </div>
  </div>

  <script type="module">
    import * as OBC from 'https://cdn.jsdelivr.net/npm/@thatopen/components@latest';
    import { IfcLoader } from 'https://cdn.jsdelivr.net/npm/web-ifc-viewer@latest';
    import Papa from 'https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js';

    // Configuración del contenedor
    const container = document.getElementById('container');

    // Inicialización de los componentes
    const components = new OBC.Components();
    const world = components.get(OBC.Worlds).create(OBC.SimpleScene, OBC.SimpleCamera, OBC.SimpleRenderer);
    world.scene = new OBC.SimpleScene(components);
    world.renderer = new OBC.SimpleRenderer(components, container);
    world.camera = new OBC.SimpleCamera(components);
    world.camera.controls.setLookAt(12, 6, 8, 0, 0, -10);

    components.init();
    world.scene.setup();

    // Variables globales
    let model;
    let schedule = [];
    const modelElements = {};
    let animationInterval;
    let isPlaying = false;

    // Cargar archivo IFC desde GitHub Pages
    const fragmentIfcLoader = components.get(OBC.IfcLoader);

    const loadIfc = async () => {
      try {
        // Ajustar la ruta al archivo IFC en GitHub Pages
        const fileResponse = await fetch('Modelo4D.ifc');
        const data = await fileResponse.arrayBuffer();
        const buffer = new Uint8Array(data);
        model = await fragmentIfcLoader.load(buffer);
        model.name = "Modelo4D";
        world.scene.three.add(model);

        // Mapear elementos del modelo a IDs de tareas
        model.traverse((child) => {
          if (child.isMesh) {
            const taskId = child.userData?.properties?.Pset_AWP?.StringProperty;
            if (taskId) {
              modelElements[taskId] = child;
            }
          }
        });

      } catch (error) {
        console.error('Error al cargar el modelo IFC:', error);
      }
    };
    loadIfc();

    // Cargar el CSV desde GitHub Pages
    const loadSchedule = () => {
      Papa.parse('4D.csv', {
        download: true,
        header: true,
        complete: function(results) {
          if (results.errors.length) {
            console.error('Errores al parsear el CSV:', results.errors);
          } else {
            schedule = results.data.filter(task => task.ID && task.Start && task.End);
            initializeSlider();
          }
        },
        error: function(err) {
          console.error('Error al cargar el archivo CSV:', err);
        }
      });
    };
    loadSchedule();

    // Variables para el control del tiempo
    let scheduleStartDate;
    let totalDuration;

    // Función para inicializar el slider y manejar la actualización del progreso
    const initializeSlider = () => {
      if (schedule.length === 0) return;

      const slider = document.getElementById('slider');
      const dateDisplay = document.getElementById('dateDisplay');
      scheduleStartDate = new Date(schedule[0].Start).getTime();
      totalDuration = calculateTotalDuration(schedule);

      slider.addEventListener('input', () => {
        const progress = slider.value / 100; // 0 a 1
        const currentTime = scheduleStartDate + totalDuration * progress;

        dateDisplay.textContent = `Fecha: ${new Date(currentTime).toLocaleDateString()}`;
        updateModelColors(currentTime);
      });

      // Inicializar visualización en la fecha de inicio
      dateDisplay.textContent = `Fecha: ${new Date(scheduleStartDate).toLocaleDateString()}`;
      updateModelColors(scheduleStartDate);
    };

    // Función para calcular la duración total desde la primera hasta la última fecha en el cronograma
    const calculateTotalDuration = (schedule) => {
      const startDate = new Date(schedule[0].Start).getTime();
      const endDate = new Date(schedule[schedule.length - 1].End).getTime();
      return endDate - startDate;
    };

    // Actualizar los colores del modelo basados en el progreso
    const updateModelColors = (currentTime) => {
      schedule.forEach((task) => {
        const taskStart = new Date(task.Start).getTime();
        const taskEnd = new Date(task.End).getTime();

        let color, opacity;
        if (currentTime < taskStart) {
          color = 0x808080; // Gris para tareas no iniciadas
          opacity = 0; // Completamente invisible
        } else if (currentTime >= taskStart && currentTime < taskEnd) {
          color = 0x00ff00; // Verde para tareas en progreso
          opacity = 0.3; // Semitransparente
        } else {
          color = 0x00ff00; // Verde para tareas completadas
          opacity = 1; // Totalmente visible
        }

        // Actualizar el elemento correspondiente en el modelo
        const element = modelElements[task.ID];
        if (element) {
          if (!Array.isArray(element.material)) {
            element.material = element.material.clone();
          }
          element.material.color.setHex(color);
          element.material.opacity = opacity;
          element.material.transparent = opacity < 1;
        }
      });
    };

    // Control de reproducción y pausa
    const playButton = document.getElementById('playButton');
    const pauseButton = document.getElementById('pauseButton');
    const slider = document.getElementById('slider');

    playButton.addEventListener('click', () => {
      if (isPlaying) return;
      isPlaying = true;
      animationInterval = setInterval(() => {
        if (slider.value < 100) {
          slider.value = parseFloat(slider.value) + 1;
          slider.dispatchEvent(new Event('input'));
        } else {
          clearInterval(animationInterval);
          isPlaying = false;
        }
      }, 500); // Avanza cada 500 ms
    });

    pauseButton.addEventListener('click', () => {
      clearInterval(animationInterval);
      isPlaying = false;
    });

    // Accesibilidad: Control del slider con el teclado
    slider.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowRight' && slider.value < 100) {
        slider.value = parseFloat(slider.value) + 1;
        slider.dispatchEvent(new Event('input'));
      } else if (event.key === 'ArrowLeft' && slider.value > 0) {
        slider.value = parseFloat(slider.value) - 1;
        slider.dispatchEvent(new Event('input'));
      }
    });

  </script>
</body>
</html>
