<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Visualizador 4D IFC Mejorado</title>
  <style>
    body, html {
      margin: 0;
      overflow: hidden;
    }
    #container {
      width: 100vw;
      height: 80vh;
    }
    #controls {
      width: 100vw;
      text-align: center;
      padding: 10px;
      background-color: #f0f0f0;
    }
    #slider {
      width: 80%;
    }
    #dateDisplay {
      font-size: 1.2em;
      margin-bottom: 10px;
    }
    #legend {
      margin-top: 10px;
    }
    .legend-item {
      display: inline-block;
      margin-right: 20px;
    }
    .legend-color {
      display: inline-block;
      width: 20px;
      height: 20px;
      vertical-align: middle;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="controls">
    <div id="dateDisplay">Fecha: --/--/----</div>
    <input type="range" id="slider" min="0" max="100" value="0">
    <div>
      <button id="playButton">Reproducir</button>
      <button id="pauseButton">Pausar</button>
    </div>
    <div id="legend">
      <div class="legend-item">
        <span class="legend-color" style="background-color: #808080;"></span>No iniciado
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background-color: rgba(0, 255, 0, 0.3);"></span>En progreso
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background-color: #00ff00;"></span>Completado
      </div>
    </div>
  </div>

  <!-- Importar bibliotecas necesarias sin usar módulos -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/loaders/IFCLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>

  <script>
    // Configuración del contenedor
    const container = document.getElementById('container');

    // Crear escena, cámara y renderizador
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    // Controles de órbita
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.set(12, 6, 8);
    controls.target.set(0, 0, -10);
    controls.update();

    // Añadir luz a la escena
    const lightColor = 0xffffff;
    const ambientLight = new THREE.AmbientLight(lightColor, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(lightColor, 1);
    directionalLight.position.set(0, 10, 0);
    scene.add(directionalLight);

    // Variables globales
    let model;
    let schedule = [];
    const modelElements = {};
    let animationInterval;
    let isPlaying = false;

    // Cargar archivo IFC
    const ifcLoader = new THREE.IFCLoader();
    ifcLoader.ifcManager.setWasmPath('https://cdn.jsdelivr.net/npm/web-ifc@latest/');

    const loadIfc = async () => {
      try {
        // Ajustar la ruta al archivo IFC en GitHub Pages
        const modelURL = 'Modelo4D.ifc';
        ifcLoader.load(modelURL, async (ifcModel) => {
          model = ifcModel;
          scene.add(model);

          // Mapear elementos del modelo a IDs de tareas
          const manager = ifcLoader.ifcManager;
          const buildingElements = await manager.getAllItemsOfType(0, IFCBUILDINGELEMENT, false);

          for (const elementID of buildingElements) {
            const psets = await manager.getPropertySets(0, elementID);
            const awpSet = psets.find(pset => pset.Name === 'Pset_AWP');
            let taskId = null;
            if (awpSet) {
              for (const prop of awpSet.HasProperties) {
                const propName = prop.Name.value;
                const propValue = prop.NominalValue.value;
                if (propName === 'StringProperty') {
                  taskId = propValue;
                  break;
                }
              }
            }
            if (taskId) {
              modelElements[taskId] = elementID;
            }
          }

          // Inicializar el slider después de cargar el modelo
          initializeSlider();

        }, undefined, (error) => {
          console.error('Error al cargar el modelo IFC:', error);
        });

      } catch (error) {
        console.error('Error en la función loadIfc:', error);
      }
    };
    loadIfc();

    // Cargar el CSV desde GitHub Pages
    const loadSchedule = () => {
      Papa.parse('4D.csv', {
        download: true,
        header: true,
        complete: function(results) {
          if (results.errors.length) {
            console.error('Errores al parsear el CSV:', results.errors);
          } else {
            schedule = results.data.filter(task => task.ID && task.Start && task.End);
            // Inicializar el slider si el modelo ya está cargado
            if (model) {
              initializeSlider();
            }
          }
        },
        error: function(err) {
          console.error('Error al cargar el archivo CSV:', err);
        }
      });
    };
    loadSchedule();

    // Variables para el control del tiempo
    let scheduleStartDate;
    let totalDuration;

    // Función para inicializar el slider y manejar la actualización del progreso
    const initializeSlider = () => {
      if (schedule.length === 0 || !model) return;

      const slider = document.getElementById('slider');
      const dateDisplay = document.getElementById('dateDisplay');
      scheduleStartDate = new Date(schedule[0].Start).getTime();
      totalDuration = calculateTotalDuration(schedule);

      slider.addEventListener('input', () => {
        const progress = slider.value / 100; // 0 a 1
        const currentTime = scheduleStartDate + totalDuration * progress;

        dateDisplay.textContent = `Fecha: ${new Date(currentTime).toLocaleDateString()}`;
        updateModelColors(currentTime);
      });

      // Inicializar visualización en la fecha de inicio
      dateDisplay.textContent = `Fecha: ${new Date(scheduleStartDate).toLocaleDateString()}`;
      updateModelColors(scheduleStartDate);
    };

    // Función para calcular la duración total desde la primera hasta la última fecha en el cronograma
    const calculateTotalDuration = (schedule) => {
      const startDate = new Date(schedule[0].Start).getTime();
      const endDate = new Date(schedule[schedule.length - 1].End).getTime();
      return endDate - startDate;
    };

    // Actualizar los colores del modelo basados en el progreso
    const updateModelColors = (currentTime) => {
      const manager = ifcLoader.ifcManager;

      schedule.forEach((task) => {
        const taskStart = new Date(task.Start).getTime();
        const taskEnd = new Date(task.End).getTime();

        let color;
        let opacity;
        if (currentTime < taskStart) {
          color = new THREE.Color(0x808080); // Gris para tareas no iniciadas
          opacity = 0; // Completamente invisible
        } else if (currentTime >= taskStart && currentTime < taskEnd) {
          color = new THREE.Color(0x00ff00); // Verde para tareas en progreso
          opacity = 0.3; // Semitransparente
        } else {
          color = new THREE.Color(0x00ff00); // Verde para tareas completadas
          opacity = 1; // Totalmente visible
        }

        const elementID = modelElements[task.ID];
        if (elementID) {
          // Aplicar el color y la opacidad al elemento
          manager.setColor(0, [elementID], color);
          manager.setOpacity(0, [elementID], opacity);
        }
      });
    };

    // Control de reproducción y pausa
    const playButton = document.getElementById('playButton');
    const pauseButton = document.getElementById('pauseButton');
    const slider = document.getElementById('slider');

    playButton.addEventListener('click', () => {
      if (isPlaying) return;
      isPlaying = true;
      animationInterval = setInterval(() => {
        if (slider.value < 100) {
          slider.value = parseFloat(slider.value) + 1;
          slider.dispatchEvent(new Event('input'));
        } else {
          clearInterval(animationInterval);
          isPlaying = false;
        }
      }, 500); // Avanza cada 500 ms
    });

    pauseButton.addEventListener('click', () => {
      clearInterval(animationInterval);
      isPlaying = false;
    });

    // Accesibilidad: Control del slider con el teclado
    slider.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowRight' && slider.value < 100) {
        slider.value = parseFloat(slider.value) + 1;
        slider.dispatchEvent(new Event('input'));
      } else if (event.key === 'ArrowLeft' && slider.value > 0) {
        slider.value = parseFloat(slider.value) - 1;
        slider.dispatchEvent(new Event('input'));
      }
    });

    // Función de animación
    const animate = () => {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

  </script>
</body>
</html>
